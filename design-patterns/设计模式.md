## 23种设计模式
《Design Patterns: Elements of Reusable Object-Oriented Software》

**创建型模式**
用于描述怎样创建对象，将对象的创建与使用分离。
1. 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
1. 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
1. 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
1. 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
1. 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
**结构型模式**
用于描述如何将类或对象按某种布局组成更大的结构。
1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
1. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
1. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
1. 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
1. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
1. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
1. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
**行为型模式**
用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。
1. 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
1. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
1. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
1. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
1. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
1. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
1. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
1. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
1. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
1. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
1. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

## 关键字
### 开闭原则
OCP （Open Closed Principle）  

软件实体应当对扩展开放，对修改关闭  
Software entities should be open for extension，but closed for modification  

当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。

高内聚，低耦合。

### 里氏替换原则
Liskov Substitution Principle，LSP

继承必须确保超类所拥有的性质在子类中仍然成立  
Inheritance should ensure that any property proved about supertype objects also holds for subtype objects  

里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。

通俗讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。  
比如：定义了一个 「鸟」 的接口，包含 「飞」 方法。燕子，老鹰可以顺利的继承这个接口，因为他们都属于鸟类，也都会飞，但是企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们也属于鸟类，但它们并不会飞。根据里氏替换原则它们就不适合继承 「鸟」 接口。正确的做法是定义一个鸟与鸵鸟更一般的接口，比如动物接口，鸵鸟继承动物接口而非鸟接口

### 依赖倒置原则
Dependence Inversion Principle，DIP

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象  
High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions

要面向接口编程，不要面向实现编程。
1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

### 单一职责原则
Single Responsibility Principle，SRP

对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
1. 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
2. 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。

单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。
* 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
* 提高类的可读性。复杂性降低，自然其可读性会提高。
* 提高系统的可维护性。可读性提高，那自然更容易维护了。
* 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。

### 接口隔离原则
Interface Segregation Principle，ISP

要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

### 迪米特法则
Law of Demeter，LoD  又叫做最少知识原则（Least Knowledge Principle，LKP)

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

它可以降低了类之间的耦合度，提高了模块的相对独立性。  
由于亲合度降低，从而提高了类的可复用率和系统的扩展性。  
但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。

### 合成复用原则
Composite Reuse Principle，CRP 又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）  

软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。  
如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。
